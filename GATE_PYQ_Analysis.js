const CN = {
  "Application Layer Protocol": [
    12, 2008, 2011, 2012, 2016, 2019, 2020, 2022, 2005, 2005, 2005, 2006, 2008,
  ],
  Bridges: [3, 2004, 2006, 2006],
  "CRC Polynomial": [4, 2007, 2017, 2021, 2005],
  "CSMA CD": [5, 2015, 2016, 2005, 2005, 2008],
  Communication: [4, 2012, 2022, 2007, 2007],
  "Congestion Control": [7, 2008, 2012, 2014, 2015, 2018, 2018, 2005],
  "Distance Vector Routing": [
    8, 2010, 2010, 2011, 2011, 2021, 2022, 2005, 2007,
  ],
  "Error Detection": [
    11, 1992, 1994, 1995, 2009, 2014, 2017, 2021, 2005, 2007, 2008, 1987,
  ],
  Ethernet: [7, 2004, 2013, 2016, 2022, 2024, 2024, 2006],
  "IP Addressing": [
    10, 2003, 2004, 2004, 2012, 2013, 2014, 2017, 2018, 2023, 2024,
  ],
  "IP Packet": [
    12, 2006, 2010, 2014, 2014, 2015, 2015, 2016, 2024, 2024, 2024, 2004, 2024,
  ],
  "LAN Technologies": [7, 2003, 2007, 2014, 2019, 2004, 2005, 2006],
  "MAC Protocol": [5, 2005, 2015, 2021, 2004, 2005],
  "Network Flow": [5, 1992, 2017, 2004, 2004, 2006],
  "Network Layering": [6, 2003, 2004, 2007, 2013, 2014, 2018],
  "Network Protocol": [
    10, 2005, 2007, 2015, 2016, 2019, 2021, 2021, 2024, 2007, 2008,
  ],
  "Network Switching": [4, 2005, 2014, 2015, 2004],
  Routing: [
    13, 2005, 2014, 2014, 2014, 2017, 2020, 2023, 2024, 2024, 2005, 2005, 2007,
    2008,
  ],
  "Sliding Window": [
    15, 2003, 2005, 2006, 2006, 2007, 2009, 2009, 2014, 2015, 2016, 2004, 2004,
    2004, 2006, 2008,
  ],
  Socket: [4, 2008, 2008, 2014, 2015],
  "Stop & Wait": [6, 2015, 2016, 2017, 2023, 2005, 2006],
  Subnetting: [
    20, 2003, 2004, 2005, 2006, 2007, 2008, 2010, 2012, 2015, 2015, 2019, 2020,
    2022, 2023, 2004, 2005, 2006, 2006, 2008, 2008,
  ],
  TCP: [
    21, 2009, 2012, 2015, 2015, 2015, 2016, 2017, 2018, 2020, 2021, 2021, 2021,
    2022, 2023, 2024, 2024, 2004, 2004, 2007, 2007, 2008,
  ],
  "Token Bucket": [2, 2008, 2016],
  UDP: [3, 2005, 2013, 2017],
};

const C = {
  Aliasing: [1, 2000],
  Array: [
    13, 2011, 2015, 2015, 2015, 2017, 2019, 2020, 2021, 2022, 2004, 2008, 2008,
    2008,
  ],
  Functions: [1, 2024],
  Goto: [2, 1989, 1994],
  "Identity Function": [6, 1995, 1998, 2017, 2017, 2019, 2004],
  "Loop Invariants": [8, 1987, 1988, 1988, 1991, 2004, 2015, 2016, 2017],
  Output: [5, 2022, 2023, 2024, 2024, 2024],
  "Parameter Passing": [
    12, 1992, 1994, 2001, 2003, 2008, 2010, 2013, 2016, 2016, 2018, 2006, 2008,
  ],
  Pointers: [
    11, 2000, 2001, 2003, 2003, 2005, 2006, 2014, 2015, 2017, 2022, 2024,
  ],
  "Programming Constructs": [1, 1999],
  "Programming in C": [
    31, 2000, 2002, 2002, 2002, 2004, 2005, 2008, 2008, 2012, 2012, 2014, 2014,
    2015, 2015, 2016, 2016, 2017, 2017, 2017, 2017, 2018, 2019, 2019, 2019,
    2021, 2024, 2004, 2004, 2005, 2006, 2007,
  ],
  "Programming Paradigms": [2, 2004, 2004],
  Recursion: [
    17, 1991, 1994, 2000, 2001, 2002, 2004, 2005, 2007, 2014, 2015, 2016, 2016,
    2017, 2017, 2018, 2020, 2007,
  ],
  Structure: [5, 2000, 2018, 2021, 2004, 2006],
  "Switch Case": [2, 2012, 2015],
  "Type Checking": [1, 2003],
  Union: [1, 2000],
  "Variable Binding": [1, 2007],
};

const DS = {
  "AVL Tree": [4, 1988, 2009, 2020, 2008],
  Array: [
    13, 1993, 1994, 1994, 1997, 1998, 2000, 2000, 2005, 2013, 2013, 2014, 2015,
    2021,
  ],
  "Binary Heap": [
    29, 1990, 1996, 1999, 2001, 2003, 2004, 2005, 2006, 2006, 2006, 2007, 2009,
    2009, 2011, 2014, 2015, 2015, 2015, 2016, 2016, 2018, 2019, 2020, 2021,
    2023, 2024, 2004, 2006, 2006,
  ],
  "Binary Search Tree": [
    34, 1996, 1996, 1997, 2001, 2003, 2003, 2003, 2004, 2004, 2005, 2005, 2008,
    2012, 2013, 2013, 2014, 2015, 2015, 2015, 2016, 2017, 2017, 2020, 2020,
    2021, 2022, 2024, 2005, 2005, 2006, 2007, 2008, 2008, 2008,
  ],
  "Binary Tree": [
    53, 1987, 1987, 1987, 1988, 1988, 1989, 1990, 1991, 1991, 1991, 1991, 1991,
    1993, 1994, 1995, 1995, 1996, 1996, 1997, 1998, 2000, 2000, 2002, 2002,
    2004, 2004, 2006, 2007, 2007, 2007, 2007, 2010, 2011, 2012, 2014, 2015,
    2015, 2015, 2016, 2018, 2019, 2021, 2023, 2024, 2024, 2004, 2005, 2006,
    2006, 2006, 2008, 2008, 2008,
  ],
  "Data Structure": [6, 1997, 2005, 2014, 2016, 2024, 2024],
  Hashing: [
    16, 1996, 1996, 1997, 2004, 2007, 2009, 2010, 2010, 2014, 2014, 2015, 2015,
    2024, 2006, 2007, 2008,
  ],
  "Infix Prefix": [5, 1989, 1997, 1998, 2004, 2007],
  "Linked List": [
    22, 1987, 1987, 1993, 1994, 1995, 1997, 1997, 1998, 1999, 2002, 2003, 2004,
    2004, 2008, 2010, 2016, 2017, 2020, 2022, 2023, 2004, 2005,
  ],
  "Priority Queue": [2, 1997, 2023],
  Queue: [
    13, 1992, 1994, 1996, 2001, 2006, 2012, 2013, 2016, 2016, 2017, 2018, 2022,
    2007,
  ],
  Stack: [
    16, 1991, 1994, 1995, 2000, 2003, 2004, 2004, 2014, 2015, 2015, 2021, 2023,
    2024, 2004, 2005, 2007,
  ],
  Tree: [
    14, 1990, 1992, 1994, 1998, 1998, 1998, 2002, 2004, 2005, 2007, 2014, 2014,
    2017, 2021,
  ],
};

const subjects = {
  "Computer Networks": CN,
  "C Programming": C,
  "Data Structures": DS,
};

// False: i.e. no fault in subject
// True: i.e. fault in subject
const verifySubjectFault = (subject) => {
  if (typeof subject != "object" || Array.isArray(subject)) {
    console.log("Invalid Subject format");
    return true;
  }

  const keys = Object.keys(subject);
  const values = Object.values(subject);

  if (values.length === 0) {
    console.log("Empty Subject");
    return true;
  }

  let faultFound = false;
  for (let i = 0; i < values.length; i++) {
    if (!Array.isArray(values[i])) {
      console.log("Invalid Topic format, i.e. Not an Array");
      console.log("Topic:", keys[i]);
      faultFound = true;
    } else {
      if (values[i][0] != values[i].length - 1) {
        console.log("No. of Question did not match the count:");
        console.log("Topic", keys[i]);
        console.log("Count:", values[i][0]);
        console.log("Questions:", values[i].length - 1);
        faultFound = true;
      }
    }
  }
  return faultFound;
};

const countTotalQuestions = (subject, year = "all") => {
  if (year == "all") year = 0;

  if (typeof year != "number") {
    console.log("Invalid Year Format:", year, typeof year);
    return null;
  }

  if (verifySubjectFault(subject)) return null;

  const keys = Object.keys(subject);
  total = 0;

  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    const value = subject[key];

    for (let j = 1; j < value.length; j++) {
      const queYear = value[j];
      if (queYear >= year) total += 1;
    }
  }
  return total;
};

const round = (num) => {
  if (typeof num != "number") {
    throw new Error("Invalid Number Format in rounding function");
  }
  return parseFloat(num.toFixed(3));
};

function sortTopicsByQuestions(subject) {
  // Convert the subject object into an array of entries [key, value]
  const sortedEntries = Object.entries(subject).sort(
    (a, b) => b[1].length - a[1].length
  ); // Sort by the length of the value array (number of questions)

  // Convert the sorted entries back into an object
  const sortedSubject = Object.fromEntries(sortedEntries);

  return sortedSubject;
}

const returnTopicPercetage = (subject, year = "all") => {
  const numOfQue = countTotalQuestions(subject, year);
  if (year == "all") year = 0;
  if (typeof numOfQue != "number") {
    return null;
  }
  const keys = Object.keys(subject);

  const updatedSubject = {};

  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    const value = subject[key];
    const topicQue = [];

    for (let j = 1; j < value.length; j++) {
      const queYear = value[j];
      if (queYear >= year) topicQue.push(queYear);
    }

    if (topicQue.length > 0) {
      updatedSubject[key] = [
        topicQue.length,
        `${round((topicQue.length * 100) / numOfQue)}%`,
        ...topicQue,
      ];
    }
  }

  return sortTopicsByQuestions(updatedSubject);
};

subjectName = Object.keys(subjects);

const queFrom = "all";
// const queFrom = 2010;
for (let i = 0; i < subjectName.length; i++) {
  console.log("Subject:", subjectName[i]);
  console.log("------------------------------------------------");
  const subject = returnTopicPercetage(subjects[subjectName[i]], queFrom);
  const topics = Object.keys(subject);
  let total = 0;
  for (let j = 0; j < topics.length; j++) {
    console.log(
      j + 1 + ".",
      topics[j],
      "|",
      subject[topics[j]][0],
      "|",
      subject[topics[j]][1]
    );

    total = total + subject[topics[j]][0];
  }
  console.log("Total: ", total);
  console.log("");
}
